function! MakeClassDefinition()
  let l:filename = substitute(expand('%'), ".*\/", "", "")
  let l:extension=matchstr(l:filename, "[.].*$")
  let l:basename=matchstr(l:filename, "^.*[.]")
  let l:basename=substitute(l:basename, "[.]$", "", "")
  let l:current_line=line(".")
  if (l:extension ==? ".h")
    call append(l:current_line, "class " . l:basename)
    call append(l:current_line + 1, "{")
    call append(l:current_line + 2, "public:")
    call append(l:current_line + 3, "  " . l:basename . "();")
    call append(l:current_line + 4, "  ~" . l:basename . "();")
    call append(l:current_line + 5, "")
    call append(l:current_line + 6, "private:")
    call append(l:current_line + 7, "};")
  elseif (l:extension == ".C" || l:extension == ".cpp")
    call append(l:current_line, "")
    call append(l:current_line + 1, "#include \"" . l:basename . ".h\"")
    call append(l:current_line + 2, "")
    call append(l:current_line + 3, l:basename . "::" . l:basename . "()")
    call append(l:current_line + 4, "{")
    call append(l:current_line + 5, "}")
    call append(l:current_line + 6, "")
    call append(l:current_line + 7, l:basename . "::~" . l:basename . "()")
    call append(l:current_line + 8, "{")
    call append(l:current_line + 9, "}")
    call append(l:current_line + 10, "")
  elseif (l:extension == ".vhd")
    let l:isentity=matchstr(l:filename, "_[Ee][Nn][Tt]\.vhd$")
    let l:isrtl=matchstr(l:filename, "_[Rr][Tt][Ll]\.vhd$")
    let l:isms=matchstr(l:filename, "_[Mm][Ss]\.vhd$")
    let l:ispck=matchstr(l:filename, "^pck_")
    if (strlen(l:isentity))
      let l:entityname=substitute(l:filename, l:isentity."$", "", "")
      call append(l:current_line, "library ieee;")
      call append(l:current_line + 1, "use ieee.std_logic_1164.all;")
      call append(l:current_line + 2, "")
      call append(l:current_line + 3, "entity " . l:entityname . " is")
      call append(l:current_line + 4, "  port (")
      call append(l:current_line + 5, "        clk     : in std_logic;")
      call append(l:current_line + 6, "        reset_n : in std_logic;")
      call append(l:current_line + 7, "")
      call append(l:current_line + 8, "       );")
      call append(l:current_line + 9, "end " . l:entityname . ";")
    elseif (strlen(l:isrtl))
      let l:entityname=substitute(l:filename, l:isrtl."$", "", "")
      call append(l:current_line, "architecture rtl of " . l:entityname . " is")
      call append(l:current_line + 1, "begin")
      call append(l:current_line + 2, "  main: process (clk, reset_n)")
      call append(l:current_line + 3, "  begin")
      call append(l:current_line + 4, "    if reset_n = '0' then")
      call append(l:current_line + 5, "    elsif clk'event and clk = '1' then")
      call append(l:current_line + 6, "    end if;")
      call append(l:current_line + 7, "  end process;")
      call append(l:current_line + 8, "end rtl;")
    elseif (strlen(l:isms))
      let l:entityname=substitute(l:filename, l:isms."$", "", "")
      call append(l:current_line, "architecture ms of " . l:entityname . " is")
      call append(l:current_line + 1, "  attribute foreign : string;")
      call append(l:current_line + 2, "  attribute foreign of ms : architecture is")
      call append(l:current_line + 3, "    \"sc_module_wrap cosim.so\";")
      call append(l:current_line + 4, "begin")
      call append(l:current_line + 5, "end ms;")
    elseif (l:ispck == "pck_")
      let l:packagename = l:basename
      call append(l:current_line, "library ieee;")
      call append(l:current_line + 1, "use ieee.std_logic_1164.all;")
      call append(l:current_line + 2, "")
      call append(l:current_line + 3, "package " . l:packagename . " is")
      call append(l:current_line + 4, "end " . l:packagename . ";")
    else
      echo "Unknown vhdl file type"
    endif
  elseif (l:extension == ".ari")
    call append(l:current_line - 1, "hierarchy " . l:basename)
    call append(l:current_line + 0, "{")
    call append(l:current_line + 1, "};")
    call append(l:current_line + 2, "")
    call append(l:current_line + 3, "info " . l:basename)
    call append(l:current_line + 4, "{")
    call append(l:current_line + 5, "};")
    normal 6k
  elseif (l:extension == ".pslt")
    call append(l:current_line - 1, l:basename . " = abbrev;")
    call append(l:current_line + 0, "")
    call append(l:current_line + 1, "signals")
    call append(l:current_line + 2, "{")
    call append(l:current_line + 3, "}")
    call append(l:current_line + 4, "")
    call append(l:current_line + 5, "vunit")
    call append(l:current_line + 6, "{")
    call append(l:current_line + 7, "}")
  elseif (l:extension == ".pslm")
    call append(l:current_line - 1, "module " . l:basename . " arch;")
    call append(l:current_line + 0, "")
    call append(l:current_line + 1, "signalmapping busintf")
    call append(l:current_line + 2, "{")
    call append(l:current_line + 3, "}")
  elseif (l:extension == ".psl")
    call append(l:current_line - 1, "vunit " . l:basename . " (ent(rtl)) {")
    call append(l:current_line + 0, "  default clock = falling_edge(clk);")
    call append(l:current_line + 1, "}")
  else
    echo l:filename . " is not a header or a source file"
  endif
endfunction

function! MakeClassDefinitionQT()
  let l:filename = substitute(expand('%'), ".*\/", "", "")
  let l:extension=matchstr(l:filename, "[.].*$")
  let l:basename=matchstr(l:filename, "^.*[.]")
  let l:basename=substitute(l:basename, "[.]$", "", "")
  let l:current_line=line(".")
  if (l:extension ==? ".h")
    call append(l:current_line, "#include <qwidget.h>")
    call append(l:current_line + 1, "")
    call append(l:current_line + 2, "class " . l:basename . " : public QWidget")
    call append(l:current_line + 3, "{")
    call append(l:current_line + 4, "  Q_OBJECT")
    call append(l:current_line + 5, "")
    call append(l:current_line + 6, "public:")
    call append(l:current_line + 7, "  " . l:basename . "(QWidget * parent, " .
                                  \ "const char * name=0);")
    call append(l:current_line + 8, "  ~" . l:basename . "();")
    call append(l:current_line + 9, "")
    call append(l:current_line + 10, "private:")
    call append(l:current_line + 11, "  void init();")
    call append(l:current_line + 12, "  void createWidgets();")
    call append(l:current_line + 13, "};")
  elseif (l:extension == ".C" || l:extension == ".cpp")
    call append(l:current_line, "")
    call append(l:current_line + 1, "#include \"" . l:basename . ".h\"")
    call append(l:current_line + 2, "#include <qlayout.h>")
    call append(l:current_line + 3, "")
    call append(l:current_line + 4, l:basename . "::" . l:basename .
                                  \ "(QWidget * parent, const char * name=0)")
    call append(l:current_line + 5, "  : QWidget(parent, name)")
    call append(l:current_line + 6, "{")
    call append(l:current_line + 7, "  init();")
    call append(l:current_line + 8, "  createWidgets();")
    call append(l:current_line + 9, "}")
    call append(l:current_line + 10, "")
    call append(l:current_line + 11, l:basename . "::~" . l:basename . "()")
    call append(l:current_line + 12, "{")
    call append(l:current_line + 13, "}")
    call append(l:current_line + 14, "")
    call append(l:current_line + 15, "void " . l:basename . "::init()")
    call append(l:current_line + 16, "{")
    call append(l:current_line + 17, "}")
    call append(l:current_line + 18, "")
    call append(l:current_line + 19, "void " . l:basename . "::createWidgets()")
    call append(l:current_line + 20, "{")
    call append(l:current_line + 21, "  QGridLayout * grid = new " .
                                   \ "QGridLayout(this);")
    call append(l:current_line + 22, "}")
    call append(l:current_line + 23, "")
  else
    echo l:filename . " is not a header or a source file"
  endif
endfunction

function! MakeClassDefinitionSystemC()
  let l:filename = substitute(expand('%'), ".*\/", "", "")
  let l:extension=matchstr(l:filename, "[.].*$")
  let l:basename=matchstr(l:filename, "^.*[.]")
  let l:basename=substitute(l:basename, "[.]$", "", "")
  let l:current_line=line(".")
  if (l:extension ==? ".h")
    call append(l:current_line, "#include <systemc>")
    call append(l:current_line + 1, "")
    call append(l:current_line + 2, "class " . l:basename .
          \ " : public sc_core::sc_module")
    call append(l:current_line + 3, "{")
    call append(l:current_line + 4, "public:")
    call append(l:current_line + 5, "  " . l:basename .
          \ "(sc_core::sc_module_name name);")
    call append(l:current_line + 6, "  ~" . l:basename . "();")
    call append(l:current_line + 7, "  SC_HAS_PROCESS(" . l:basename . ");")
    call append(l:current_line + 8, "")
    call append(l:current_line + 9, "private:")
    call append(l:current_line + 10, "};")
  elseif (l:extension == ".C" || l:extension == ".cpp")
    call append(l:current_line, "")
    call append(l:current_line + 1, "#include \"" . l:basename . ".h\"")
    call append(l:current_line + 2, "")
    call append(l:current_line + 3, l:basename . "::" . l:basename .
          \ "(sc_core::sc_module_name name)")
    call append(l:current_line + 4 , "  : sc_core::sc_module(name),")
    call append(l:current_line + 5 , "{")
    call append(l:current_line + 6 , "}")
    call append(l:current_line + 7 , "")
    call append(l:current_line + 8 , l:basename . "::~" . l:basename . "()")
    call append(l:current_line + 9 , "{")
    call append(l:current_line + 10, "}")
    call append(l:current_line + 11, "")
  else
    echo l:filename . " is not a header or a source file"
  endif
endfunction
